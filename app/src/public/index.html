<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <meta http-equiv="Cache-control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>Face Landmarker</title>

  <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
  <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
  <link rel="stylesheet" href="/static/style.css">
</head>

<body>
  <section id="demos" class="invisible">
    <div id="liveView" class="videoView">
 
      <div>
        <video id="webcam" autoplay playsinline width="480" height="360"></video>
        <nav>
            <button id="webcamButton" class="mdc-button mdc-button--raised">
                <span class="mdc-button__ripple"></span>
                <span class="mdc-button__label">▶</span>
              </button>
        </nav>
        <canvas id="output_canvas" class="output_canvas"></canvas>
      </div>
    
    </div>
    <div class="blend-shapes">
      <ul id="video-blend-shapes" class="blend-shapes-list"></ul>
    </div>
  </section>

  <script type="module">
    import vision from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";
    const { FaceLandmarker, FilesetResolver, DrawingUtils } = vision;

    const demosSection = document.getElementById("demos");
    const videoBlendShapes = document.getElementById("video-blend-shapes");
    const webcamButton = document.getElementById("webcamButton");
    const video = document.getElementById("webcam");
    const canvasElement = document.getElementById("output_canvas");
    const canvasCtx = canvasElement.getContext("2d");

    const videoWidth = 480;
    let faceLandmarker, runningMode = "IMAGE", webcamRunning = false;
    let lastVideoTime = -1;
    let results = undefined;
    const drawingUtils = new DrawingUtils(canvasCtx);

    async function initializeFaceLandmarker() {
      const filesetResolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
      faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
          delegate: "GPU"
        },
        outputFaceBlendshapes: true,
        runningMode: "IMAGE",
        numFaces: 1
      });
      demosSection.classList.remove("invisible");
    }

    function hasGetUserMedia() {
      return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    }

    function toggleWebcam() {
      if (!faceLandmarker) return console.log("FaceLandmarker não carregado ainda.");
      webcamRunning = !webcamRunning;
      webcamButton.innerText = webcamRunning ? "DISABLE PREDICTIONS" : "ENABLE PREDICTIONS";

      if (webcamRunning) {
        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
          video.srcObject = stream;
          video.addEventListener("loadeddata", predictWebcam);
        });
      }
    }

    async function predictWebcam() {
      const aspectRatio = video.videoHeight / video.videoWidth;
      Object.assign(video.style, { width: `${videoWidth}px`, height: `${videoWidth * aspectRatio}px` });
      Object.assign(canvasElement.style, { width: `${videoWidth}px`, height: `${videoWidth * aspectRatio}px` });
      canvasElement.width = video.videoWidth;
      canvasElement.height = video.videoHeight;

      if (runningMode !== "VIDEO") {
        runningMode = "VIDEO";
        await faceLandmarker.setOptions({ runningMode });
      }

      const startTimeMs = performance.now();
      if (lastVideoTime !== video.currentTime) {
        lastVideoTime = video.currentTime;
        results = faceLandmarker.detectForVideo(video, startTimeMs);
      }

      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      if (results.faceLandmarks) {
        results.faceLandmarks.forEach((landmarks) => drawLandmarks(drawingUtils, landmarks));
      }
      drawBlendShapes(videoBlendShapes, results.faceBlendshapes);

      if (webcamRunning) {
        requestAnimationFrame(predictWebcam);
      }
    }

    function drawLandmarks(utils, landmarks) {
      const colors = {
        TESSELATION: "#C0C0C070",
        RIGHT_EYE: "#FF3030",
        RIGHT_EYEBROW: "#FF3030",
        LEFT_EYE: "#30FF30",
        LEFT_EYEBROW: "#30FF30",
        FACE_OVAL: "#E0E0E0",
        LIPS: "#E0E0E0",
        RIGHT_IRIS: "#FF3030",
        LEFT_IRIS: "#30FF30"
      };

      utils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_TESSELATION, { color: colors.TESSELATION, lineWidth: 1 });
      utils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_RIGHT_EYE, { color: colors.RIGHT_EYE });
      utils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_RIGHT_EYEBROW, { color: colors.RIGHT_EYEBROW });
      utils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_LEFT_EYE, { color: colors.LEFT_EYE });
      utils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_LEFT_EYEBROW, { color: colors.LEFT_EYEBROW });
      utils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_FACE_OVAL, { color: colors.FACE_OVAL });
      utils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_LIPS, { color: colors.LIPS });
      utils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_RIGHT_IRIS, { color: colors.RIGHT_IRIS });
      utils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_LEFT_IRIS, { color: colors.LEFT_IRIS });
    }

    function drawBlendShapes(container, blendShapes) {
      if (!blendShapes.length) return;

      console.log({shape:  blendShapes[0].categories[16].displayName || blendShapes[0].categories[16].categoryName});
      
      container.innerHTML = blendShapes[0].categories.map((shape) => `
        <li class="blend-shapes-item">
          <span class="blend-shapes-label">${shape.displayName || shape.categoryName}</span>
          <span class="blend-shapes-value" style="width: calc(${+shape.score * 100}% - 120px)">${(+shape.score).toFixed(4)}</span>
        </li>
      `).join("");
    }

    // Inicializa tudo
    initializeFaceLandmarker();
    if (hasGetUserMedia()) webcamButton.addEventListener("click", toggleWebcam);
    else console.warn("getUserMedia() não é suportado neste navegador.");

  </script>
</body>
</html>
